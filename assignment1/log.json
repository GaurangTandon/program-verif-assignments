{"1584027847.4801006": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 1, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584028787.0281029": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 1, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584029123.4361525": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       int[M][N] prod;\n       return prod;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 1, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584029642.9882128": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n  // sketch won't compile if assertion fails\n}\n"}, "1584029686.7182918": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n  /* sketch won't compile if assertion fails */\n}\n"}, "1584029827.8342": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       return prod;\n}\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584030009.8928986": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584030306.9543693": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584031765.0859098": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) implements product {\n  assume P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584031789.852014": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584031833.4203892": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584031926.7163074": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n       int[M][N] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\n}\n"}, "1584032428.7463005": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n  while(head.next !=null){\n    head = head.next;\n  }\n  head.next = n;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(n == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return;\n  }\n\n  assert(head != null);\n  Node prev = head;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val = 70;\n}\n"}, "1584032436.2311149": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n  while(head.next !=null){\n    head = head.next;\n  }\n  head.next = n;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(n == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return;\n  }\n\n  assert(head != null);\n  Node prev = head;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584032451.254108": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n  while(head.next !=null){\n    head = head.next;\n  }\n  head.next = n;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(n == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n  Node prev = head;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584032473.4650607": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n  while(head.next !=null){\n    head = head.next;\n  }\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n  Node prev = head;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584032510.3424103": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n  while(head.next !=null){\n    head = head.next;\n  }\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n  Node prev = head;\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584038895.7576418": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584039781.310975": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > ??){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n1, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 50;\n}\n"}, "1584039835.7567134": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n1, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 50;\n}\n"}, "1584039856.0177314": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 50;\n}\n"}, "1584039868.485707": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n}\n"}, "1584039919.9439836": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n}\n"}, "1584039997.7878256": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 2);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 100;\n  assert l2.head.next.next.next.val == 60;\n}\n"}, "1584040004.0210178": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 2);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 100;\n  assert l2.head.next.next.next.val == 60;\n}\n"}, "1584040063.7220063": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 70;\n}\n"}, "1584040079.2895346": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040375.1922703": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040382.162417": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  asser l.head.val == 45\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040399.7640254": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040407.3603082": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == 0){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > 0){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040743.32536": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = lst.head;\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > ??){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040776.7328293": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > ??){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040797.882408": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = n;\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > ??){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040830.2564402": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = {| lst.head | n | n.next |};\n    return lst;\n  }\n\n  assert(head != null);\n\n  pos--;\n\n  while(pos > ??){\n    pos--;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040874.7163842": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = {| lst.head | n | n.next |};\n    return lst;\n  }\n\n  assert(head != null);\n\n  int decrease = ??;\n  pos -= decrease;\n\n  while(pos > ??){\n    pos -= decrease;\n    assert(head != null);\n    head = head.next;\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040897.806338": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = {| lst.head | n | n.next |};\n    return lst;\n  }\n\n  assert(head != null);\n\n  int decrease = ??;\n  pos -= decrease;\n\n  while(pos > ??){\n    pos -= decrease;\n    assert(head != null);\n    head = {| head.next | head.next.next |};\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584040986.2478368": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = head.next;\n  }\n\n  head.next = n;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = {| lst.head | n | n.next |};\n    return lst;\n  }\n\n  assert(head != null);\n\n  int decrease = ??;\n  pos -= decrease;\n\n  while(pos > ??){\n    pos -= decrease;\n    assert(head != null);\n    head = {| head.next | head.next.next |};\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert somewhere between\n  Node n4 = new Node(next = null, val = 95);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n4, 2);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 95;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584106655.4088411": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node head = lst.head;\n\n  if(head == null){\n    lst.head = n;\n    return lst;\n  }\n\n  while(head.next != null){\n    head = {| head.next | head.next.next |};\n  }\n\n  head.next = {| head | n |};\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node head = {| lst.head | lst.head.next |};\n\n  if(pos == ??){\n    n.next = head;\n    lst.head = {| lst.head | n | n.next |};\n    return lst;\n  }\n\n  assert(head != null);\n\n  int decrease = ??;\n  pos -= decrease;\n\n  while(pos > ??){\n    pos -= decrease;\n    assert(head != null);\n    head = {| head.next | head.next.next |};\n  }\n\n  n.next = head.next;\n  head.next = n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 65 -> 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n0 = new Node(next = n2, val = 5);\n  Node n1 = new Node(next = n0, val = 65);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n\n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.next.val == 40;\n\n  Node n0 = new Node(next = null, val = 45);\n  l = new List();\n  l = append(l, n0);\n  assert l.head.val == 45;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  // test insert at 1\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  assert l2.head.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at 0 at front\n  Node n2 = new Node(next = null, val = 90);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n2, 0);\n  assert l2.head.val == 90;\n  assert l2.head.next.val == 65;\n  assert l2.head.next.next.val == 5;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert somewhere between\n  Node n4 = new Node(next = null, val = 95);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n4, 2);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 95;\n  assert l2.head.next.next.next.val == 60;\n\n  // test insert at far end\n  Node n3 = new Node(next = null, val = 100);\n  l = new List();\n  l = populate(l);\n  l2 = insertAt(l, n3, 3);\n  assert l2.head.val == 65;\n  assert l2.head.next.val == 5;\n  assert l2.head.next.next.val == 60;\n  assert l2.head.next.next.next.val == 100;\n}\n"}, "1584106770.269546": {"problem_number": 2, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n       int[{| M | N | P | Q |}][{| M | N | P | Q |}] prod;\n       int sum = 0;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n}\n       return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\n}\n"}, "1584107091.0883524": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n  int[{| M | N | P | Q |}][{| M | N | P | Q |}] prod;\n\n  int sum = 0;\n\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < Q; j++) {\n\t    sum = 0;\n\t    for (int k = 0; k < P; k++) {\n\t\t    sum += a[i, k] * b[k, j];\n\t\t  }\n\t    prod[i][j] = sum;\n\t  }\n  }\n\n  return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\nassert productSK(2, 4, 4, 5, {{4,7,7,6},{3,7,5,9}},{{6,3,3,0,7},{8,7,9,1,8},{5,8,4,6,4},{8,2,1,10,4}}) == {{163,129,109,109,136},{171,116,101,127,133}};\nassert productSK(3, 4, 4, 5, {{0,6,10,0},{5,4,0,3},{0,2,2,6}},{{3,0,3,7,6},{9,2,7,3,3},{10,9,0,10,7},{8,3,5,6,6}}) == {{154,102,42,118,88},{75,17,58,65,60},{86,40,44,62,56}};\nassert productSK(4, 4, 4, 3, {{8,0,7,7},{4,3,5,7},{4,1,0,10},{8,7,3,8}},{{7,2,7},{9,5,8},{4,5,4},{0,1,9}}) == {{84,58,147},{75,55,135},{37,23,126},{131,74,196}};\nassert productSK(3, 4, 4, 4, {{6,6,2,6},{5,5,7,6},{9,1,2,8}},{{8,5,7,4},{9,10,2,6},{5,4,2,8},{8,4,4,1}}) == {{160,122,82,82},{168,127,83,112},{155,95,101,66}};\nassert productSK(4, 1, 1, 2, {{9},{1},{2},{2}},{{3,8}}) == {{27,72},{3,8},{6,16},{6,16}};\nassert productSK(3, 2, 2, 2, {{3,10},{5,5},{5,3}},{{2,6},{4,9}}) == {{46,108},{30,75},{22,57}};\nassert productSK(1, 5, 5, 6, {{0,0,0,10,2}},{{4,7,7,5,7,5},{1,3,0,8,6,7},{2,3,1,6,7,9},{0,6,10,9,3,4},{5,0,8,10,3,6}}) == {{10,60,116,110,36,52}};\nassert productSK(1, 4, 4, 2, {{6,8,6,0}},{{1,2},{8,3},{6,5},{10,0}}) == {{106,66}};\nassert productSK(1, 2, 2, 3, {{1,7}},{{10,4,8},{0,5,3}}) == {{10,39,29}};\nassert productSK(6, 1, 1, 5, {{10},{3},{7},{0},{9},{4}},{{5,7,0,10,6}}) == {{50,70,0,100,60},{15,21,0,30,18},{35,49,0,70,42},{0,0,0,0,0},{45,63,0,90,54},{20,28,0,40,24}};\nassert productSK(6, 5, 5, 5, {{2,5,7,5,2},{9,8,6,6,3},{9,4,1,6,0},{7,6,4,2,3},{5,8,6,0,6},{4,5,1,4,5}},{{9,4,5,5,6},{4,5,4,5,8},{2,6,2,4,5},{9,2,1,6,1},{4,9,1,7,10}}) == {{105,103,51,107,112},{191,151,98,166,184},{153,74,69,105,97},{125,113,72,114,142},{113,150,75,131,184},{114,100,51,108,123}};\nassert productSK(1, 5, 5, 5, {{2,1,0,0,9}},{{5,8,0,0,3},{9,2,6,8,5},{10,1,4,9,3},{3,4,1,7,1},{10,8,10,0,3}}) == {{109,90,96,8,38}};\nassert productSK(2, 4, 4, 6, {{1,7,6,2},{6,7,9,0}},{{4,2,3,7,3,3},{1,10,3,5,9,5},{9,10,8,6,1,4},{6,2,8,2,7,5}}) == {{77,136,88,82,86,72},{112,172,111,131,90,89}};\nassert productSK(4, 2, 2, 2, {{2,7},{7,6},{8,4},{4,8}},{{4,2},{4,1}}) == {{36,11},{52,20},{48,20},{48,16}};\nassert productSK(6, 1, 1, 2, {{9},{6},{1},{2},{9},{7}},{{4,5}}) == {{36,45},{24,30},{4,5},{8,10},{36,45},{28,35}};\nassert productSK(3, 2, 2, 6, {{5,3},{6,1},{10,0}},{{7,7,0,3,1,3},{9,7,7,3,3,5}}) == {{62,56,21,24,14,30},{51,49,7,21,9,23},{70,70,0,30,10,30}};\nassert productSK(1, 5, 5, 5, {{6,5,0,0,3}},{{0,7,1,10,1},{5,2,10,9,0},{10,9,0,0,4},{4,9,3,9,3},{0,9,5,6,5}}) == {{25,79,71,123,21}};\nassert productSK(5, 1, 1, 5, {{4},{1},{5},{9},{3}},{{2,8,10,9,2}}) == {{8,32,40,36,8},{2,8,10,9,2},{10,40,50,45,10},{18,72,90,81,18},{6,24,30,27,6}};\nassert productSK(2, 3, 3, 1, {{10,3,10},{9,3,2}},{{9},{7},{4}}) == {{151},{110}};\nassert productSK(6, 3, 3, 6, {{4,0,7},{0,6,10},{2,8,9},{5,2,2},{6,1,10},{1,10,0}},{{8,10,5,0,7,10},{8,9,10,4,4,9},{8,8,0,5,7,9}}) == {{88,96,20,35,77,103},{128,134,60,74,94,144},{152,164,90,77,109,173},{72,84,45,18,57,86},{136,149,40,54,116,159},{88,100,105,40,47,100}};\n}\n"}, "1584110150.226673": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\ngenerator int[2] sizesGen(int[4] sizes, int i, int j){\n  if(j == 4){\n    i = i + 1;\n    j = 0;\n  }\n\n  if(??) return {sizes[i], sizes[j]};\n\n  if(!(i == ?? && j == ??)) return sizesGen(sizes, i, j + 1);\n\n  return {0, 0};\n}\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n  int[2] szs = sizesGen({M,N,P,Q,0,0});\n  int[szs[0]][szs[1]] prod;\n\n  int sum;\n\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < Q; j++) {\n\t    sum = ??;\n\t    for (int k = 0; k < P; k++) {\n\t\t    sum += a[i, k] * b[k, j];\n\t\t  }\n\n\t    prod[i][j] = sum;\n\t  }\n  }\n\n  return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\nassert productSK(2, 4, 4, 5, {{4,7,7,6},{3,7,5,9}},{{6,3,3,0,7},{8,7,9,1,8},{5,8,4,6,4},{8,2,1,10,4}}) == {{163,129,109,109,136},{171,116,101,127,133}};\nassert productSK(3, 4, 4, 5, {{0,6,10,0},{5,4,0,3},{0,2,2,6}},{{3,0,3,7,6},{9,2,7,3,3},{10,9,0,10,7},{8,3,5,6,6}}) == {{154,102,42,118,88},{75,17,58,65,60},{86,40,44,62,56}};\nassert productSK(4, 4, 4, 3, {{8,0,7,7},{4,3,5,7},{4,1,0,10},{8,7,3,8}},{{7,2,7},{9,5,8},{4,5,4},{0,1,9}}) == {{84,58,147},{75,55,135},{37,23,126},{131,74,196}};\nassert productSK(3, 4, 4, 4, {{6,6,2,6},{5,5,7,6},{9,1,2,8}},{{8,5,7,4},{9,10,2,6},{5,4,2,8},{8,4,4,1}}) == {{160,122,82,82},{168,127,83,112},{155,95,101,66}};\nassert productSK(4, 1, 1, 2, {{9},{1},{2},{2}},{{3,8}}) == {{27,72},{3,8},{6,16},{6,16}};\nassert productSK(3, 2, 2, 2, {{3,10},{5,5},{5,3}},{{2,6},{4,9}}) == {{46,108},{30,75},{22,57}};\nassert productSK(1, 5, 5, 6, {{0,0,0,10,2}},{{4,7,7,5,7,5},{1,3,0,8,6,7},{2,3,1,6,7,9},{0,6,10,9,3,4},{5,0,8,10,3,6}}) == {{10,60,116,110,36,52}};\nassert productSK(1, 4, 4, 2, {{6,8,6,0}},{{1,2},{8,3},{6,5},{10,0}}) == {{106,66}};\nassert productSK(1, 2, 2, 3, {{1,7}},{{10,4,8},{0,5,3}}) == {{10,39,29}};\nassert productSK(6, 1, 1, 5, {{10},{3},{7},{0},{9},{4}},{{5,7,0,10,6}}) == {{50,70,0,100,60},{15,21,0,30,18},{35,49,0,70,42},{0,0,0,0,0},{45,63,0,90,54},{20,28,0,40,24}};\nassert productSK(6, 5, 5, 5, {{2,5,7,5,2},{9,8,6,6,3},{9,4,1,6,0},{7,6,4,2,3},{5,8,6,0,6},{4,5,1,4,5}},{{9,4,5,5,6},{4,5,4,5,8},{2,6,2,4,5},{9,2,1,6,1},{4,9,1,7,10}}) == {{105,103,51,107,112},{191,151,98,166,184},{153,74,69,105,97},{125,113,72,114,142},{113,150,75,131,184},{114,100,51,108,123}};\nassert productSK(1, 5, 5, 5, {{2,1,0,0,9}},{{5,8,0,0,3},{9,2,6,8,5},{10,1,4,9,3},{3,4,1,7,1},{10,8,10,0,3}}) == {{109,90,96,8,38}};\nassert productSK(2, 4, 4, 6, {{1,7,6,2},{6,7,9,0}},{{4,2,3,7,3,3},{1,10,3,5,9,5},{9,10,8,6,1,4},{6,2,8,2,7,5}}) == {{77,136,88,82,86,72},{112,172,111,131,90,89}};\nassert productSK(4, 2, 2, 2, {{2,7},{7,6},{8,4},{4,8}},{{4,2},{4,1}}) == {{36,11},{52,20},{48,20},{48,16}};\nassert productSK(6, 1, 1, 2, {{9},{6},{1},{2},{9},{7}},{{4,5}}) == {{36,45},{24,30},{4,5},{8,10},{36,45},{28,35}};\nassert productSK(3, 2, 2, 6, {{5,3},{6,1},{10,0}},{{7,7,0,3,1,3},{9,7,7,3,3,5}}) == {{62,56,21,24,14,30},{51,49,7,21,9,23},{70,70,0,30,10,30}};\nassert productSK(1, 5, 5, 5, {{6,5,0,0,3}},{{0,7,1,10,1},{5,2,10,9,0},{10,9,0,0,4},{4,9,3,9,3},{0,9,5,6,5}}) == {{25,79,71,123,21}};\nassert productSK(5, 1, 1, 5, {{4},{1},{5},{9},{3}},{{2,8,10,9,2}}) == {{8,32,40,36,8},{2,8,10,9,2},{10,40,50,45,10},{18,72,90,81,18},{6,24,30,27,6}};\nassert productSK(2, 3, 3, 1, {{10,3,10},{9,3,2}},{{9},{7},{4}}) == {{151},{110}};\nassert productSK(6, 3, 3, 6, {{4,0,7},{0,6,10},{2,8,9},{5,2,2},{6,1,10},{1,10,0}},{{8,10,5,0,7,10},{8,9,10,4,4,9},{8,8,0,5,7,9}}) == {{88,96,20,35,77,103},{128,134,60,74,94,144},{152,164,90,77,109,173},{72,84,45,18,57,86},{136,149,40,54,116,159},{88,100,105,40,47,100}};\n}\n"}, "1584110163.8437188": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\ngenerator int[2] sizesGen(int[4] sizes, int i, int j){\n  if(j == 4){\n    i = i + 1;\n    j = 0;\n  }\n\n  if(??) return {sizes[i], sizes[j]};\n\n  if(!(i == ?? && j == ??)) return sizesGen(sizes, i, j + 1);\n\n  return {0, 0};\n}\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n  int[2] szs = sizesGen({M,N,P,Q,0,0});\n  int[szs[0]][szs[1]] prod;\n\n  int sum;\n\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < Q; j++) {\n\t    sum = ??;\n\t    for (int k = 0; k < P; k++) {\n\t\t    sum += a[i, k] * b[k, j];\n\t\t  }\n\n\t    prod[i][j] = sum;\n\t  }\n  }\n\n  return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\nassert productSK(2, 4, 4, 5, {{4,7,7,6},{3,7,5,9}},{{6,3,3,0,7},{8,7,9,1,8},{5,8,4,6,4},{8,2,1,10,4}}) == {{163,129,109,109,136},{171,116,101,127,133}};\nassert productSK(3, 4, 4, 5, {{0,6,10,0},{5,4,0,3},{0,2,2,6}},{{3,0,3,7,6},{9,2,7,3,3},{10,9,0,10,7},{8,3,5,6,6}}) == {{154,102,42,118,88},{75,17,58,65,60},{86,40,44,62,56}};\nassert productSK(4, 4, 4, 3, {{8,0,7,7},{4,3,5,7},{4,1,0,10},{8,7,3,8}},{{7,2,7},{9,5,8},{4,5,4},{0,1,9}}) == {{84,58,147},{75,55,135},{37,23,126},{131,74,196}};\nassert productSK(3, 4, 4, 4, {{6,6,2,6},{5,5,7,6},{9,1,2,8}},{{8,5,7,4},{9,10,2,6},{5,4,2,8},{8,4,4,1}}) == {{160,122,82,82},{168,127,83,112},{155,95,101,66}};\nassert productSK(4, 1, 1, 2, {{9},{1},{2},{2}},{{3,8}}) == {{27,72},{3,8},{6,16},{6,16}};\nassert productSK(3, 2, 2, 2, {{3,10},{5,5},{5,3}},{{2,6},{4,9}}) == {{46,108},{30,75},{22,57}};\nassert productSK(1, 5, 5, 6, {{0,0,0,10,2}},{{4,7,7,5,7,5},{1,3,0,8,6,7},{2,3,1,6,7,9},{0,6,10,9,3,4},{5,0,8,10,3,6}}) == {{10,60,116,110,36,52}};\nassert productSK(1, 4, 4, 2, {{6,8,6,0}},{{1,2},{8,3},{6,5},{10,0}}) == {{106,66}};\nassert productSK(1, 2, 2, 3, {{1,7}},{{10,4,8},{0,5,3}}) == {{10,39,29}};\nassert productSK(6, 1, 1, 5, {{10},{3},{7},{0},{9},{4}},{{5,7,0,10,6}}) == {{50,70,0,100,60},{15,21,0,30,18},{35,49,0,70,42},{0,0,0,0,0},{45,63,0,90,54},{20,28,0,40,24}};\nassert productSK(6, 5, 5, 5, {{2,5,7,5,2},{9,8,6,6,3},{9,4,1,6,0},{7,6,4,2,3},{5,8,6,0,6},{4,5,1,4,5}},{{9,4,5,5,6},{4,5,4,5,8},{2,6,2,4,5},{9,2,1,6,1},{4,9,1,7,10}}) == {{105,103,51,107,112},{191,151,98,166,184},{153,74,69,105,97},{125,113,72,114,142},{113,150,75,131,184},{114,100,51,108,123}};\nassert productSK(1, 5, 5, 5, {{2,1,0,0,9}},{{5,8,0,0,3},{9,2,6,8,5},{10,1,4,9,3},{3,4,1,7,1},{10,8,10,0,3}}) == {{109,90,96,8,38}};\nassert productSK(2, 4, 4, 6, {{1,7,6,2},{6,7,9,0}},{{4,2,3,7,3,3},{1,10,3,5,9,5},{9,10,8,6,1,4},{6,2,8,2,7,5}}) == {{77,136,88,82,86,72},{112,172,111,131,90,89}};\nassert productSK(4, 2, 2, 2, {{2,7},{7,6},{8,4},{4,8}},{{4,2},{4,1}}) == {{36,11},{52,20},{48,20},{48,16}};\nassert productSK(6, 1, 1, 2, {{9},{6},{1},{2},{9},{7}},{{4,5}}) == {{36,45},{24,30},{4,5},{8,10},{36,45},{28,35}};\nassert productSK(3, 2, 2, 6, {{5,3},{6,1},{10,0}},{{7,7,0,3,1,3},{9,7,7,3,3,5}}) == {{62,56,21,24,14,30},{51,49,7,21,9,23},{70,70,0,30,10,30}};\nassert productSK(1, 5, 5, 5, {{6,5,0,0,3}},{{0,7,1,10,1},{5,2,10,9,0},{10,9,0,0,4},{4,9,3,9,3},{0,9,5,6,5}}) == {{25,79,71,123,21}};\nassert productSK(5, 1, 1, 5, {{4},{1},{5},{9},{3}},{{2,8,10,9,2}}) == {{8,32,40,36,8},{2,8,10,9,2},{10,40,50,45,10},{18,72,90,81,18},{6,24,30,27,6}};\nassert productSK(2, 3, 3, 1, {{10,3,10},{9,3,2}},{{9},{7},{4}}) == {{151},{110}};\nassert productSK(6, 3, 3, 6, {{4,0,7},{0,6,10},{2,8,9},{5,2,2},{6,1,10},{1,10,0}},{{8,10,5,0,7,10},{8,9,10,4,4,9},{8,8,0,5,7,9}}) == {{88,96,20,35,77,103},{128,134,60,74,94,144},{152,164,90,77,109,173},{72,84,45,18,57,86},{136,149,40,54,116,159},{88,100,105,40,47,100}};\n}\n"}, "1584110175.7961776": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\ngenerator int[2] sizesGen(int[4] sizes, int i, int j){\n  if(j == 4){\n    i = i + 1;\n    j = 0;\n  }\n\n  if(??) return {sizes[i], sizes[j]};\n\n  if(!(i == ?? && j == ??)) return sizesGen(sizes, i, j + 1);\n\n  return {0, 0};\n}\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n  int[2] szs = sizesGen({M,N,P,Q},0,0);\n  int[szs[0]][szs[1]] prod;\n\n  int sum;\n\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < Q; j++) {\n\t    sum = ??;\n\t    for (int k = 0; k < P; k++) {\n\t\t    sum += a[i, k] * b[k, j];\n\t\t  }\n\n\t    prod[i][j] = sum;\n\t  }\n  }\n\n  return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\nassert productSK(2, 4, 4, 5, {{4,7,7,6},{3,7,5,9}},{{6,3,3,0,7},{8,7,9,1,8},{5,8,4,6,4},{8,2,1,10,4}}) == {{163,129,109,109,136},{171,116,101,127,133}};\nassert productSK(3, 4, 4, 5, {{0,6,10,0},{5,4,0,3},{0,2,2,6}},{{3,0,3,7,6},{9,2,7,3,3},{10,9,0,10,7},{8,3,5,6,6}}) == {{154,102,42,118,88},{75,17,58,65,60},{86,40,44,62,56}};\nassert productSK(4, 4, 4, 3, {{8,0,7,7},{4,3,5,7},{4,1,0,10},{8,7,3,8}},{{7,2,7},{9,5,8},{4,5,4},{0,1,9}}) == {{84,58,147},{75,55,135},{37,23,126},{131,74,196}};\nassert productSK(3, 4, 4, 4, {{6,6,2,6},{5,5,7,6},{9,1,2,8}},{{8,5,7,4},{9,10,2,6},{5,4,2,8},{8,4,4,1}}) == {{160,122,82,82},{168,127,83,112},{155,95,101,66}};\nassert productSK(4, 1, 1, 2, {{9},{1},{2},{2}},{{3,8}}) == {{27,72},{3,8},{6,16},{6,16}};\nassert productSK(3, 2, 2, 2, {{3,10},{5,5},{5,3}},{{2,6},{4,9}}) == {{46,108},{30,75},{22,57}};\nassert productSK(1, 5, 5, 6, {{0,0,0,10,2}},{{4,7,7,5,7,5},{1,3,0,8,6,7},{2,3,1,6,7,9},{0,6,10,9,3,4},{5,0,8,10,3,6}}) == {{10,60,116,110,36,52}};\nassert productSK(1, 4, 4, 2, {{6,8,6,0}},{{1,2},{8,3},{6,5},{10,0}}) == {{106,66}};\nassert productSK(1, 2, 2, 3, {{1,7}},{{10,4,8},{0,5,3}}) == {{10,39,29}};\nassert productSK(6, 1, 1, 5, {{10},{3},{7},{0},{9},{4}},{{5,7,0,10,6}}) == {{50,70,0,100,60},{15,21,0,30,18},{35,49,0,70,42},{0,0,0,0,0},{45,63,0,90,54},{20,28,0,40,24}};\nassert productSK(6, 5, 5, 5, {{2,5,7,5,2},{9,8,6,6,3},{9,4,1,6,0},{7,6,4,2,3},{5,8,6,0,6},{4,5,1,4,5}},{{9,4,5,5,6},{4,5,4,5,8},{2,6,2,4,5},{9,2,1,6,1},{4,9,1,7,10}}) == {{105,103,51,107,112},{191,151,98,166,184},{153,74,69,105,97},{125,113,72,114,142},{113,150,75,131,184},{114,100,51,108,123}};\nassert productSK(1, 5, 5, 5, {{2,1,0,0,9}},{{5,8,0,0,3},{9,2,6,8,5},{10,1,4,9,3},{3,4,1,7,1},{10,8,10,0,3}}) == {{109,90,96,8,38}};\nassert productSK(2, 4, 4, 6, {{1,7,6,2},{6,7,9,0}},{{4,2,3,7,3,3},{1,10,3,5,9,5},{9,10,8,6,1,4},{6,2,8,2,7,5}}) == {{77,136,88,82,86,72},{112,172,111,131,90,89}};\nassert productSK(4, 2, 2, 2, {{2,7},{7,6},{8,4},{4,8}},{{4,2},{4,1}}) == {{36,11},{52,20},{48,20},{48,16}};\nassert productSK(6, 1, 1, 2, {{9},{6},{1},{2},{9},{7}},{{4,5}}) == {{36,45},{24,30},{4,5},{8,10},{36,45},{28,35}};\nassert productSK(3, 2, 2, 6, {{5,3},{6,1},{10,0}},{{7,7,0,3,1,3},{9,7,7,3,3,5}}) == {{62,56,21,24,14,30},{51,49,7,21,9,23},{70,70,0,30,10,30}};\nassert productSK(1, 5, 5, 5, {{6,5,0,0,3}},{{0,7,1,10,1},{5,2,10,9,0},{10,9,0,0,4},{4,9,3,9,3},{0,9,5,6,5}}) == {{25,79,71,123,21}};\nassert productSK(5, 1, 1, 5, {{4},{1},{5},{9},{3}},{{2,8,10,9,2}}) == {{8,32,40,36,8},{2,8,10,9,2},{10,40,50,45,10},{18,72,90,81,18},{6,24,30,27,6}};\nassert productSK(2, 3, 3, 1, {{10,3,10},{9,3,2}},{{9},{7},{4}}) == {{151},{110}};\nassert productSK(6, 3, 3, 6, {{4,0,7},{0,6,10},{2,8,9},{5,2,2},{6,1,10},{1,10,0}},{{8,10,5,0,7,10},{8,9,10,4,4,9},{8,8,0,5,7,9}}) == {{88,96,20,35,77,103},{128,134,60,74,94,144},{152,164,90,77,109,173},{72,84,45,18,57,86},{136,149,40,54,116,159},{88,100,105,40,47,100}};\n}\n"}, "1584110194.4858332": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\ngenerator int[2] sizesGen(int[4] sizes, int i, int j){\n  if(j == 4){\n    i = i + 1;\n    j = 0;\n  }\n\n  if(??) return {sizes[i], sizes[j]};\n\n  if(!(i == ?? && j == ??)) return sizesGen(sizes, i, j + 1);\n\n  return {0, 0};\n}\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n  int[2] szs = sizesGen({M,N,P,Q},0,0);\n  int[szs[0]][szs[1]] prod;\n\n  int sum;\n\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < Q; j++) {\n\t    sum = ??;\n\t    for (int k = 0; k < P; k++) {\n\t\t    sum += a[i, k] * b[k, j];\n\t\t  }\n\n\t    prod[i][j] = sum;\n\t  }\n  }\n\n  return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\nassert productSK(2, 4, 4, 5, {{4,7,7,6},{3,7,5,9}},{{6,3,3,0,7},{8,7,9,1,8},{5,8,4,6,4},{8,2,1,10,4}}) == {{163,129,109,109,136},{171,116,101,127,133}};\nassert productSK(3, 4, 4, 5, {{0,6,10,0},{5,4,0,3},{0,2,2,6}},{{3,0,3,7,6},{9,2,7,3,3},{10,9,0,10,7},{8,3,5,6,6}}) == {{154,102,42,118,88},{75,17,58,65,60},{86,40,44,62,56}};\nassert productSK(4, 4, 4, 3, {{8,0,7,7},{4,3,5,7},{4,1,0,10},{8,7,3,8}},{{7,2,7},{9,5,8},{4,5,4},{0,1,9}}) == {{84,58,147},{75,55,135},{37,23,126},{131,74,196}};\nassert productSK(3, 4, 4, 4, {{6,6,2,6},{5,5,7,6},{9,1,2,8}},{{8,5,7,4},{9,10,2,6},{5,4,2,8},{8,4,4,1}}) == {{160,122,82,82},{168,127,83,112},{155,95,101,66}};\nassert productSK(4, 1, 1, 2, {{9},{1},{2},{2}},{{3,8}}) == {{27,72},{3,8},{6,16},{6,16}};\nassert productSK(3, 2, 2, 2, {{3,10},{5,5},{5,3}},{{2,6},{4,9}}) == {{46,108},{30,75},{22,57}};\nassert productSK(1, 5, 5, 6, {{0,0,0,10,2}},{{4,7,7,5,7,5},{1,3,0,8,6,7},{2,3,1,6,7,9},{0,6,10,9,3,4},{5,0,8,10,3,6}}) == {{10,60,116,110,36,52}};\nassert productSK(1, 4, 4, 2, {{6,8,6,0}},{{1,2},{8,3},{6,5},{10,0}}) == {{106,66}};\nassert productSK(1, 2, 2, 3, {{1,7}},{{10,4,8},{0,5,3}}) == {{10,39,29}};\nassert productSK(6, 1, 1, 5, {{10},{3},{7},{0},{9},{4}},{{5,7,0,10,6}}) == {{50,70,0,100,60},{15,21,0,30,18},{35,49,0,70,42},{0,0,0,0,0},{45,63,0,90,54},{20,28,0,40,24}};\nassert productSK(6, 5, 5, 5, {{2,5,7,5,2},{9,8,6,6,3},{9,4,1,6,0},{7,6,4,2,3},{5,8,6,0,6},{4,5,1,4,5}},{{9,4,5,5,6},{4,5,4,5,8},{2,6,2,4,5},{9,2,1,6,1},{4,9,1,7,10}}) == {{105,103,51,107,112},{191,151,98,166,184},{153,74,69,105,97},{125,113,72,114,142},{113,150,75,131,184},{114,100,51,108,123}};\nassert productSK(1, 5, 5, 5, {{2,1,0,0,9}},{{5,8,0,0,3},{9,2,6,8,5},{10,1,4,9,3},{3,4,1,7,1},{10,8,10,0,3}}) == {{109,90,96,8,38}};\nassert productSK(2, 4, 4, 6, {{1,7,6,2},{6,7,9,0}},{{4,2,3,7,3,3},{1,10,3,5,9,5},{9,10,8,6,1,4},{6,2,8,2,7,5}}) == {{77,136,88,82,86,72},{112,172,111,131,90,89}};\nassert productSK(4, 2, 2, 2, {{2,7},{7,6},{8,4},{4,8}},{{4,2},{4,1}}) == {{36,11},{52,20},{48,20},{48,16}};\nassert productSK(6, 1, 1, 2, {{9},{6},{1},{2},{9},{7}},{{4,5}}) == {{36,45},{24,30},{4,5},{8,10},{36,45},{28,35}};\nassert productSK(3, 2, 2, 6, {{5,3},{6,1},{10,0}},{{7,7,0,3,1,3},{9,7,7,3,3,5}}) == {{62,56,21,24,14,30},{51,49,7,21,9,23},{70,70,0,30,10,30}};\nassert productSK(1, 5, 5, 5, {{6,5,0,0,3}},{{0,7,1,10,1},{5,2,10,9,0},{10,9,0,0,4},{4,9,3,9,3},{0,9,5,6,5}}) == {{25,79,71,123,21}};\nassert productSK(5, 1, 1, 5, {{4},{1},{5},{9},{3}},{{2,8,10,9,2}}) == {{8,32,40,36,8},{2,8,10,9,2},{10,40,50,45,10},{18,72,90,81,18},{6,24,30,27,6}};\nassert productSK(2, 3, 3, 1, {{10,3,10},{9,3,2}},{{9},{7},{4}}) == {{151},{110}};\nassert productSK(6, 3, 3, 6, {{4,0,7},{0,6,10},{2,8,9},{5,2,2},{6,1,10},{1,10,0}},{{8,10,5,0,7,10},{8,9,10,4,4,9},{8,8,0,5,7,9}}) == {{88,96,20,35,77,103},{128,134,60,74,94,144},{152,164,90,77,109,173},{72,84,45,18,57,86},{136,149,40,54,116,159},{88,100,105,40,47,100}};\n}\n"}, "1584110451.423758": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk\n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\n\ngenerator int[2] sizesGen(int[4] sizes, int i, int j){\n  if(j == 4){\n    i = i + 1;\n    j = 0;\n  }\n\n  if(??) return {sizes[i], sizes[j]};\n\n  if(!(i == ?? && j == ??)) return sizesGen(sizes, i, j + 1);\n\n  return {0, 0};\n}\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  assert P == N;\n  int[2] szs = sizesGen({M,N,P,Q},0,0);\n  int[szs[0]][szs[1]] prod;\n\n  int sum;\n\n  for (int i = 0; i < {| M | N | P | Q |}; i++) {\n    for (int j = 0; j < {| M | N | P | Q |}; j++) {\n\t    sum = ??;\n\t    for (int k = 0; k < {| M | N | P | Q |}; k++) {\n\t\t    sum += a[i, k] * b[k, j];\n\t\t  }\n\n\t    prod[i][j] = sum;\n\t  }\n  }\n\n  return prod;\n}\n\n\nharness void multTest(){\n  /* sketch won't compile if assertion fails */\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\nassert productSK(6, 1, 1, 1, {{4},{3},{3},{2},{1},{10}},{{8}}) == {{32},{24},{24},{16},{8},{80}};\nassert productSK(1, 5, 5, 4, {{0,0,1,3,3}},{{8,9,0,8},{3,10,8,6},{3,7,9,4},{0,2,6,5},{4,2,3,5}}) == {{15,19,36,34}};\nassert productSK(1, 1, 1, 4, {{1}},{{5,5,9,4}}) == {{5,5,9,4}};\nassert productSK(1, 6, 6, 4, {{8,1,6,1,8,4}},{{10,9,5,9},{3,1,0,10},{3,4,1,3},{1,6,4,7},{10,5,2,5},{5,3,10,4}}) == {{202,155,106,163}};\nassert productSK(6, 6, 6, 6, {{1,9,10,2,8,3},{2,7,6,4,10,8},{3,10,5,0,3,0},{5,6,4,1,3,9},{5,3,10,7,6,10},{7,2,4,2,3,8}},{{8,4,9,6,9,6},{5,3,2,8,7,1},{0,1,2,10,2,10},{6,9,1,6,6,9},{7,8,4,8,0,10},{1,10,8,4,10,5}}) == {{124,153,105,266,134,228},{153,231,152,264,183,255},{95,71,69,172,107,108},{106,165,150,184,191,160},{149,250,182,284,228,306},{107,160,153,166,177,172}};\nassert productSK(1, 3, 3, 4, {{2,7,0}},{{4,8,2,8},{1,10,4,10},{8,9,3,2}}) == {{15,86,32,86}};\nassert productSK(3, 2, 2, 5, {{8,0},{9,5},{7,0}},{{1,5,4,3,0},{3,9,1,1,7}}) == {{8,40,32,24,0},{24,90,41,32,35},{7,35,28,21,0}};\nassert productSK(1, 5, 5, 2, {{2,10,7,8,2}},{{4,8},{9,6},{3,8},{3,4},{6,10}}) == {{155,184}};\nassert productSK(6, 3, 3, 4, {{8,7,1},{3,3,1},{5,0,9},{8,3,9},{3,0,1},{10,0,3}},{{1,0,5,1},{8,3,4,10},{7,3,8,2}}) == {{71,24,76,80},{34,12,35,35},{68,27,97,23},{95,36,124,56},{10,3,23,5},{31,9,74,16}};\nassert productSK(6, 5, 5, 5, {{7,3,7,6,3},{1,1,10,6,5},{6,6,7,0,10},{10,10,1,0,6},{5,1,3,3,3},{8,7,2,6,2}},{{4,7,3,1,7},{8,1,0,10,8},{0,1,3,2,6},{7,7,3,6,0},{2,6,0,6,4}}) == {{100,119,60,105,127},{64,90,51,97,95},{92,115,39,140,172},{132,117,33,148,180},{55,78,33,57,73},{134,119,48,130,132}};\nassert productSK(4, 3, 3, 4, {{8,10,7},{2,3,4},{3,0,9},{8,0,5}},{{0,0,9,7},{8,8,2,0},{8,1,2,1}}) == {{136,87,106,63},{56,28,32,18},{72,9,45,30},{40,5,82,61}};\nassert productSK(5, 1, 1, 6, {{3},{6},{1},{9},{3}},{{9,9,0,9,1,6}}) == {{27,27,0,27,3,18},{54,54,0,54,6,36},{9,9,0,9,1,6},{81,81,0,81,9,54},{27,27,0,27,3,18}};\nassert productSK(6, 5, 5, 5, {{8,5,4,3,10},{5,3,4,6,2},{10,10,4,7,5},{1,0,7,9,9},{1,1,8,3,8},{4,2,5,1,3}},{{5,4,2,7,8},{4,9,10,8,0},{10,8,4,10,1},{2,4,1,1,8},{2,4,4,9,3}}) == {{126,161,125,229,122},{93,111,70,123,98},{154,210,163,242,155},{111,132,75,167,114},{111,121,79,170,64},{86,90,61,122,54}};\nassert productSK(6, 3, 3, 2, {{10,10,4},{8,7,4},{0,1,10},{6,4,0},{0,5,2},{10,4,2}},{{7,8},{6,8},{0,1}}) == {{130,164},{98,124},{6,18},{66,80},{30,42},{94,114}};\nassert productSK(1, 6, 6, 2, {{8,0,5,9,8,2}},{{6,2},{0,4},{5,0},{5,3},{10,3},{10,1}}) == {{218,69}};\nassert productSK(3, 5, 5, 4, {{9,2,3,2,2},{6,0,2,5,6},{10,3,4,2,1}},{{6,0,7,3},{3,7,5,4},{3,3,0,10},{3,6,5,4},{1,4,5,10}}) == {{77,43,93,93},{63,60,97,118},{88,49,100,100}};\nassert productSK(5, 4, 4, 6, {{8,5,0,1},{4,2,9,4},{0,1,9,6},{5,5,6,9},{8,1,6,9}},{{3,4,0,6,0,8},{8,10,10,3,5,6},{1,10,5,9,5,10},{1,4,8,4,10,6}}) == {{65,86,58,67,35,100},{41,142,97,127,95,158},{23,124,103,108,110,132},{70,166,152,135,145,184},{47,138,112,141,125,184}};\nassert productSK(3, 4, 4, 6, {{4,8,2,3},{6,10,6,10},{2,9,9,4}},{{6,8,0,4,4,3},{6,9,9,10,5,7},{7,7,10,3,8,7},{2,10,1,4,8,10}}) == {{92,148,95,114,96,112},{158,280,160,182,202,230},{137,200,175,141,157,172}};\nassert productSK(6, 5, 5, 3, {{1,3,10,4,3},{3,2,0,0,3},{7,9,1,7,6},{10,9,3,6,7},{6,3,2,10,0},{1,6,3,2,8}},{{7,0,8},{3,1,7},{2,7,10},{8,8,9},{5,7,9}}) == {{83,126,192},{42,23,65},{164,114,246},{186,127,290},{135,97,179},{87,99,170}};\nassert productSK(6, 5, 5, 4, {{8,7,2,7,7},{4,3,10,4,8},{7,10,3,4,7},{1,4,3,4,5},{5,8,1,2,2},{3,6,2,3,1}},{{6,6,5,8},{7,6,0,3},{6,6,9,0},{9,6,7,0},{5,4,6,6}}) == {{207,172,149,127},{181,158,186,89},{201,172,132,128},{113,92,90,50},{120,104,60,76},{104,88,60,48}};\nassert productSK(2, 4, 4, 5, {{4,7,7,6},{3,7,5,9}},{{6,3,3,0,7},{8,7,9,1,8},{5,8,4,6,4},{8,2,1,10,4}}) == {{163,129,109,109,136},{171,116,101,127,133}};\nassert productSK(3, 4, 4, 5, {{0,6,10,0},{5,4,0,3},{0,2,2,6}},{{3,0,3,7,6},{9,2,7,3,3},{10,9,0,10,7},{8,3,5,6,6}}) == {{154,102,42,118,88},{75,17,58,65,60},{86,40,44,62,56}};\nassert productSK(4, 4, 4, 3, {{8,0,7,7},{4,3,5,7},{4,1,0,10},{8,7,3,8}},{{7,2,7},{9,5,8},{4,5,4},{0,1,9}}) == {{84,58,147},{75,55,135},{37,23,126},{131,74,196}};\nassert productSK(3, 4, 4, 4, {{6,6,2,6},{5,5,7,6},{9,1,2,8}},{{8,5,7,4},{9,10,2,6},{5,4,2,8},{8,4,4,1}}) == {{160,122,82,82},{168,127,83,112},{155,95,101,66}};\nassert productSK(4, 1, 1, 2, {{9},{1},{2},{2}},{{3,8}}) == {{27,72},{3,8},{6,16},{6,16}};\nassert productSK(3, 2, 2, 2, {{3,10},{5,5},{5,3}},{{2,6},{4,9}}) == {{46,108},{30,75},{22,57}};\nassert productSK(1, 5, 5, 6, {{0,0,0,10,2}},{{4,7,7,5,7,5},{1,3,0,8,6,7},{2,3,1,6,7,9},{0,6,10,9,3,4},{5,0,8,10,3,6}}) == {{10,60,116,110,36,52}};\nassert productSK(1, 4, 4, 2, {{6,8,6,0}},{{1,2},{8,3},{6,5},{10,0}}) == {{106,66}};\nassert productSK(1, 2, 2, 3, {{1,7}},{{10,4,8},{0,5,3}}) == {{10,39,29}};\nassert productSK(6, 1, 1, 5, {{10},{3},{7},{0},{9},{4}},{{5,7,0,10,6}}) == {{50,70,0,100,60},{15,21,0,30,18},{35,49,0,70,42},{0,0,0,0,0},{45,63,0,90,54},{20,28,0,40,24}};\nassert productSK(6, 5, 5, 5, {{2,5,7,5,2},{9,8,6,6,3},{9,4,1,6,0},{7,6,4,2,3},{5,8,6,0,6},{4,5,1,4,5}},{{9,4,5,5,6},{4,5,4,5,8},{2,6,2,4,5},{9,2,1,6,1},{4,9,1,7,10}}) == {{105,103,51,107,112},{191,151,98,166,184},{153,74,69,105,97},{125,113,72,114,142},{113,150,75,131,184},{114,100,51,108,123}};\nassert productSK(1, 5, 5, 5, {{2,1,0,0,9}},{{5,8,0,0,3},{9,2,6,8,5},{10,1,4,9,3},{3,4,1,7,1},{10,8,10,0,3}}) == {{109,90,96,8,38}};\nassert productSK(2, 4, 4, 6, {{1,7,6,2},{6,7,9,0}},{{4,2,3,7,3,3},{1,10,3,5,9,5},{9,10,8,6,1,4},{6,2,8,2,7,5}}) == {{77,136,88,82,86,72},{112,172,111,131,90,89}};\nassert productSK(4, 2, 2, 2, {{2,7},{7,6},{8,4},{4,8}},{{4,2},{4,1}}) == {{36,11},{52,20},{48,20},{48,16}};\nassert productSK(6, 1, 1, 2, {{9},{6},{1},{2},{9},{7}},{{4,5}}) == {{36,45},{24,30},{4,5},{8,10},{36,45},{28,35}};\nassert productSK(3, 2, 2, 6, {{5,3},{6,1},{10,0}},{{7,7,0,3,1,3},{9,7,7,3,3,5}}) == {{62,56,21,24,14,30},{51,49,7,21,9,23},{70,70,0,30,10,30}};\nassert productSK(1, 5, 5, 5, {{6,5,0,0,3}},{{0,7,1,10,1},{5,2,10,9,0},{10,9,0,0,4},{4,9,3,9,3},{0,9,5,6,5}}) == {{25,79,71,123,21}};\nassert productSK(5, 1, 1, 5, {{4},{1},{5},{9},{3}},{{2,8,10,9,2}}) == {{8,32,40,36,8},{2,8,10,9,2},{10,40,50,45,10},{18,72,90,81,18},{6,24,30,27,6}};\nassert productSK(2, 3, 3, 1, {{10,3,10},{9,3,2}},{{9},{7},{4}}) == {{151},{110}};\nassert productSK(6, 3, 3, 6, {{4,0,7},{0,6,10},{2,8,9},{5,2,2},{6,1,10},{1,10,0}},{{8,10,5,0,7,10},{8,9,10,4,4,9},{8,8,0,5,7,9}}) == {{88,96,20,35,77,103},{128,134,60,74,94,144},{152,164,90,77,109,173},{72,84,45,18,57,86},{136,149,40,54,116,159},{88,100,105,40,47,100}};\n}\n"}}